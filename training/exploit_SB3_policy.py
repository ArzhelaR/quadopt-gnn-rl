import copy
import yaml

import gymnasium as gym
import numpy as np
import pandas as pd
import random

from sympy.physics.quantum.gate import normalized
from tqdm import tqdm
from numpy import ndarray
from stable_baselines3 import PPO

from mesh_model.mesh_analysis.global_mesh_analysis import GlobalMeshAnalysis
from mesh_model.mesh_analysis.quadmesh_analysis import QuadMeshTopoAnalysis
from mesh_model.mesh_struct.mesh import Mesh
from mesh_model.mesh_struct.mesh_elements import Dart
from mesh_model.reader import read_gmsh, read_dataset, read_json
from mesh_model.writer import write_dataset
from view.mesh_plotter.create_plots import plot_test_results, plot_density
from view.mesh_plotter.mesh_plots import plot_dataset, plot_mesh
from environment.actions.smoothing import smoothing_mean

from environment.quadmesh_env.wrappers import MeanRewardWrapper, WeightedRewardWrapper, CleanupWrapper
from environment import quadmesh_env


def testPolicy(
        model,
        n_eval_episodes: int,
        config,
        dataset: list[Mesh]
) -> pd.DataFrame:
    """
    Tests policy on each mesh of a dataset with n_eval_episodes.
    :param model: the model to test
    :param n_eval_episodes: number of evaluation episodes on each mesh
    :param config: configuration
    :param dataset: list of mesh objects
    :return: average length of evaluation episodes, number of wins,average reward per mesh, dataset with the modified meshes
    """
    print('Testing policy')
    avg_length = np.zeros(len(dataset))
    avg_mesh_rewards = np.zeros(len(dataset))
    avg_normalized_return = np.zeros(len(dataset))
    avg_mean_std = np.zeros(len(dataset))
    list_normalized_return = np.zeros(n_eval_episodes)
    nb_wins = np.zeros(len(dataset))
    final_meshes = []
    for i, mesh in tqdm(enumerate(dataset, 1)):
        best_mesh = mesh
        env = gym.make(
            config["eval"]["eval_env_id"],
            max_episode_steps=config["eval"]["max_episode_steps"],
            learning_mesh = mesh,
            #mesh_size = 30,
            n_darts_selected=config["eval"]["n_darts_selected"],
            deep= config["eval"]["deep"],
            action_restriction=config["eval"]["action_restriction"],
            with_degree_obs=config["eval"]["with_quality_observation"],
            render_mode = config["eval"]["render_mode"],
            analysis_type=config["env"]["analysis_type"],
            debug=False,
        )
        # env = CleanupWrapper(env)
        for ne in range(n_eval_episodes):
            terminated = False
            truncated = False
            ep_mesh_rewards: int = 0
            ep_length: int = 0
            obs, info = env.reset(options={"mesh": copy.deepcopy(mesh)})
            while terminated == False and truncated == False:
                action, _states = model.predict(obs, deterministic=False)
                if action is None:
                    env.terminal = True
                    break
                obs, reward, terminated, truncated, info = env.step(action)
                ep_mesh_rewards += info['mesh_reward']
                ep_length += 1
            if terminated:
                nb_wins[i-1] += 1
            if isBetterMesh(best_mesh, info['mesh'], config["env"]["analysis_type"]):
                best_mesh = copy.deepcopy(info['mesh'])
            avg_length[i-1] += ep_length
            avg_mesh_rewards[i-1] += ep_mesh_rewards
            list_normalized_return[ne-1] =  0 if info['mesh_ideal_rewards'] == 0 else ep_mesh_rewards/info['mesh_ideal_rewards']
            avg_normalized_return[i-1] += 0 if info['mesh_ideal_rewards'] == 0 else ep_mesh_rewards/info['mesh_ideal_rewards']
        final_meshes.append(best_mesh)
        avg_length[i-1] = avg_length[i-1]/n_eval_episodes
        avg_mesh_rewards[i-1] = avg_mesh_rewards[i-1]/n_eval_episodes
        avg_normalized_return[i-1] = avg_normalized_return[i-1]/n_eval_episodes
        avg_mean_std[i-1] = np.std(list_normalized_return)

    # CrÃ©ation du DataFrame
    df_results = pd.DataFrame({
        "mesh_id": range(len(dataset)),
        "avg_length": avg_length,
        "nb_wins": nb_wins,
        "avg_mesh_rewards": avg_mesh_rewards,
        "avg_normalized_return": avg_normalized_return,
        "std_normalized_return": avg_mean_std,
        "final_mesh": final_meshes
    })

    return df_results


def isBetterPolicy(actual_best_policy, policy_to_test):
    if actual_best_policy is None:
        return True

def isBetterMesh(best_mesh, actual_mesh, analysis_type):
    ma_best_mesh = QuadMeshTopoAnalysis(best_mesh)
    ma_actual_mesh = QuadMeshTopoAnalysis(actual_mesh)
    if best_mesh is None or ma_best_mesh.global_score()[1] > ma_actual_mesh.global_score()[1]:
        return True
    else:
        return False

if __name__ == '__main__':

    #Create a dataset of 9 meshes
    #mesh = read_gmsh("../mesh_files/tri-delaunay.msh")
    # ma = TriMeshQualityAnalysis(mesh)
    # split_edge_ids(ma, 5, 2)
    # flip_edge_ids(ma, 3,7)
    # #plot_mesh(mesh)

    # PARAMETERS CONFIGURATION
    with open("../training/config/quadmesh_config_PPO_SB3.yaml", "r") as f:
        config = yaml.safe_load(f)

    dataset = read_dataset(config["dataset"]["exploit_dataset_dir"]) #[ read_gmsh("../mesh_files/bunny.msh")]
    plot_dataset(dataset)

    #Load the model
    model = PPO.load("policy_saved/quad-sb3/6-actions-obs36-v1.zip")
    df_results = testPolicy(model, 10, config, dataset)

    #plot_test_results(df_results["avg_mesh_rewards"], df_results["nb_wins"], df_results["avg_length"], df_results["avg_normalized_return"])
    final_meshes = df_results["final_mesh"]
    plot_dataset(final_meshes)
    for m in final_meshes:
        smoothing_mean(m)
    plot_dataset(final_meshes)
    print(df_results[["mesh_id", "avg_normalized_return", "std_normalized_return"]])
    df_results.to_csv("SB3-obs36-step300.csv", index=False)
    write_dataset("../training/dataset/6-actions-obs36-mixed-v0", final_meshes)
